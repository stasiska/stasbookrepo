// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.20.3
// source: post_service.proto

/* eslint-disable */
import { type handleUnaryCall, type UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "post_service";

export interface CreatePostDto {
  content: string;
  mediaUrl: string;
  mediaType: string;
  authorId: string;
}

export interface GetPostByIdDto {
  postId: string;
}

export interface GetPostByUserIdDto {
  authorId: string;
}

export interface Posts {
  posts: Post[];
}

export interface LikePostDto {
  postId: string;
  userId: string;
}

export interface CommentPostDto {
  postId: string;
  userId: string;
  text: string;
}

export interface Post {
  id: string;
  content: string;
  media: Media[];
  authorId: string;
  createdAt: Timestamp | undefined;
  updatedAt: Timestamp | undefined;
  likes: Like[];
  comments: Comment[];
}

export interface Like {
  id: string;
  postId: string;
  userId: string;
  createdAt: Timestamp | undefined;
}

export interface Comment {
  id: string;
  postId: string;
  userId: string;
  text: string;
  createdAt: Timestamp | undefined;
}

export interface Media {
  id: string;
  url: string;
  postId: string;
  type: string;
}

export const POST_SERVICE_PACKAGE_NAME = "post_service";

function createBaseCreatePostDto(): CreatePostDto {
  return { content: "", mediaUrl: "", mediaType: "", authorId: "" };
}

export const CreatePostDto = {
  encode(message: CreatePostDto, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    if (message.mediaUrl !== "") {
      writer.uint32(18).string(message.mediaUrl);
    }
    if (message.mediaType !== "") {
      writer.uint32(26).string(message.mediaType);
    }
    if (message.authorId !== "") {
      writer.uint32(34).string(message.authorId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreatePostDto {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePostDto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mediaUrl = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mediaType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.authorId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetPostByIdDto(): GetPostByIdDto {
  return { postId: "" };
}

export const GetPostByIdDto = {
  encode(message: GetPostByIdDto, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.postId !== "") {
      writer.uint32(10).string(message.postId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPostByIdDto {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPostByIdDto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.postId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetPostByUserIdDto(): GetPostByUserIdDto {
  return { authorId: "" };
}

export const GetPostByUserIdDto = {
  encode(message: GetPostByUserIdDto, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.authorId !== "") {
      writer.uint32(10).string(message.authorId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPostByUserIdDto {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPostByUserIdDto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.authorId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBasePosts(): Posts {
  return { posts: [] };
}

export const Posts = {
  encode(message: Posts, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.posts) {
      Post.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Posts {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePosts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.posts.push(Post.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseLikePostDto(): LikePostDto {
  return { postId: "", userId: "" };
}

export const LikePostDto = {
  encode(message: LikePostDto, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.postId !== "") {
      writer.uint32(10).string(message.postId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LikePostDto {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLikePostDto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.postId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCommentPostDto(): CommentPostDto {
  return { postId: "", userId: "", text: "" };
}

export const CommentPostDto = {
  encode(message: CommentPostDto, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.postId !== "") {
      writer.uint32(10).string(message.postId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CommentPostDto {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommentPostDto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.postId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBasePost(): Post {
  return {
    id: "",
    content: "",
    media: [],
    authorId: "",
    createdAt: undefined,
    updatedAt: undefined,
    likes: [],
    comments: [],
  };
}

export const Post = {
  encode(message: Post, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    for (const v of message.media) {
      Media.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.authorId !== "") {
      writer.uint32(34).string(message.authorId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(42).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.likes) {
      Like.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.comments) {
      Comment.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Post {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.media.push(Media.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.authorId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.likes.push(Like.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.comments.push(Comment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseLike(): Like {
  return { id: "", postId: "", userId: "", createdAt: undefined };
}

export const Like = {
  encode(message: Like, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.postId !== "") {
      writer.uint32(18).string(message.postId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Like {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLike();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.postId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseComment(): Comment {
  return { id: "", postId: "", userId: "", text: "", createdAt: undefined };
}

export const Comment = {
  encode(message: Comment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.postId !== "") {
      writer.uint32(18).string(message.postId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Comment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.postId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.text = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseMedia(): Media {
  return { id: "", url: "", postId: "", type: "" };
}

export const Media = {
  encode(message: Media, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.postId !== "") {
      writer.uint32(26).string(message.postId);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Media {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMedia();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.postId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

export interface PostServiceClient {
  createPost(request: CreatePostDto): Observable<Post>;

  getPostById(request: GetPostByIdDto): Observable<Post>;

  getPostByUserId(request: GetPostByUserIdDto): Observable<Posts>;

  likePost(request: LikePostDto): Observable<Post>;

  commentPost(request: CommentPostDto): Observable<Post>;
}

export interface PostServiceController {
  createPost(request: CreatePostDto): Observable<Post>;

  getPostById(request: GetPostByIdDto): Observable<Post>;

  getPostByUserId(request: GetPostByUserIdDto): Observable<Posts>;

  likePost(request: LikePostDto): Observable<Post>;

  commentPost(request: CommentPostDto): Observable<Post>;
}

export function PostServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["createPost", "getPostById", "getPostByUserId", "likePost", "commentPost"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("PostService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("PostService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const POST_SERVICE_NAME = "PostService";

export type PostServiceService = typeof PostServiceService;
export const PostServiceService = {
  createPost: {
    path: "/post_service.PostService/CreatePost",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePostDto) => Buffer.from(CreatePostDto.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreatePostDto.decode(value),
    responseSerialize: (value: Post) => Buffer.from(Post.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Post.decode(value),
  },
  getPostById: {
    path: "/post_service.PostService/GetPostById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPostByIdDto) => Buffer.from(GetPostByIdDto.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPostByIdDto.decode(value),
    responseSerialize: (value: Post) => Buffer.from(Post.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Post.decode(value),
  },
  getPostByUserId: {
    path: "/post_service.PostService/GetPostByUserId",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPostByUserIdDto) => Buffer.from(GetPostByUserIdDto.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPostByUserIdDto.decode(value),
    responseSerialize: (value: Posts) => Buffer.from(Posts.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Posts.decode(value),
  },
  likePost: {
    path: "/post_service.PostService/LikePost",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LikePostDto) => Buffer.from(LikePostDto.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LikePostDto.decode(value),
    responseSerialize: (value: Post) => Buffer.from(Post.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Post.decode(value),
  },
  commentPost: {
    path: "/post_service.PostService/CommentPost",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CommentPostDto) => Buffer.from(CommentPostDto.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CommentPostDto.decode(value),
    responseSerialize: (value: Post) => Buffer.from(Post.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Post.decode(value),
  },
} as const;

export interface PostServiceServer extends UntypedServiceImplementation {
  createPost: handleUnaryCall<CreatePostDto, Post>;
  getPostById: handleUnaryCall<GetPostByIdDto, Post>;
  getPostByUserId: handleUnaryCall<GetPostByUserIdDto, Posts>;
  likePost: handleUnaryCall<LikePostDto, Post>;
  commentPost: handleUnaryCall<CommentPostDto, Post>;
}
